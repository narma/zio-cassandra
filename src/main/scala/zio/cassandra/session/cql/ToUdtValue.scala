package zio.cassandra.session.cql

import com.datastax.oss.driver.api.core.`type`.UserDefinedType
import com.datastax.oss.driver.api.core.cql.BoundStatement
import com.datastax.oss.driver.api.core.data.UdtValue
import zio.cassandra.session.cql.ToUdtValue.{ make, makeWithFieldName }

import scala.annotation.nowarn

/** A typeclass that is used to turn a Scala datatype into a UdtValue. Typeclass instances for FromUdtValue are
  * (inductively) derived from CassandraTypeMapper
  *
  * @tparam Scala
  *   is the Scala datatype that you intend to convert into a Cassandra UdtValue
  */
trait ToUdtValue[-Scala] { self =>
  def convert(fieldName: FieldName, input: Scala, constructor: UdtValue): UdtValue

  def contramap[AnotherScala](f: AnotherScala => Scala): ToUdtValue[AnotherScala] =
    (fieldName: FieldName, input: AnotherScala, constructor: UdtValue) => self.convert(fieldName, f(input), constructor)
}

object ToUdtValue extends LowerPriorityToUdtValue with LowestPriorityToUdtValue {
  // represents a ToUdtValue whose UdtValue is fully set up
  // this can only be generated by the Shapeless machinery
  trait Object[-A] extends ToUdtValue[A]

  def deriveBinder[A](implicit ev: ToUdtValue.Object[A]): Binder[A] = {
    (statement: BoundStatement, index: Int, value: A) =>
      val constructor = statement.getType(index).asInstanceOf[UserDefinedType]
      val udtValue    = ev.convert(FieldName.Unused, value, constructor.newValue())
      (statement.setUdtValue(index, udtValue), index + 1)
  }

  // only allowed to summon fully built out ToUdtValue instances which are built by Shapeless machinery
  def apply[A](implicit ev: ToUdtValue.Object[A]): ToUdtValue.Object[A] = ev

  def make[A](mk: (A, UdtValue) => UdtValue): ToUdtValue[A] =
    (fieldName: FieldName, input: A, constructor: UdtValue) =>
      fieldName match {
        case FieldName.Unused =>
          mk(input, constructor)

        case FieldName.Labelled(value) =>
          throw new RuntimeException(s"ToUdtValue failure: Expected an unused fieldName for $input but got $value")
      }

  def makeWithFieldName[A](mk: (String, A, UdtValue) => UdtValue): ToUdtValue[A] =
    (fieldName: FieldName, input: A, constructor: UdtValue) =>
      fieldName match {
        case FieldName.Unused =>
          throw new RuntimeException(s"ToUdtValue failure: Expected a labelled fieldName for $input but got unused")

        case FieldName.Labelled(fieldName) =>
          mk(fieldName, input, constructor)
      }
}
trait LowerPriorityToUdtValue {

  /** ToUdtValue relies on the CassandraTypeMapper to convert Scala datatypes into datatypes compatible with the
    * Datastax Java driver (bi-directionally) in order to produce instances of FromUdtValue[A]. CassandraTypeMapper will
    * also inductively derive instances if you have nested data-types (collections within collections or collections
    * within UdtValues within collections or any combinations of these types) inside your UdtValue
    *
    * @param ev
    *   is evidence that we can materialize a CassandraTypeMapper for A
    * @tparam A
    *   is the Scala datatype that we would like to convert into the Datastax Java type
    * @return
    */
  implicit def deriveFromCassandraTypeMapper[A](implicit
    ev: CassandraTypeMapper[A]
  ): ToUdtValue[A] =
    makeWithFieldName[A] { (fieldName, input, constructor) =>
      constructor.set[ev.Cassandra](fieldName, ev.toCassandra(input, constructor.getType(fieldName)), ev.classType)
    }
}

trait LowestPriorityToUdtValue {
  import shapeless._
  import shapeless.labelled._
  implicit def hListToUdtValue[K <: Symbol, H, T <: HList](implicit
    witness: Witness.Aux[K],
    hToUdtValue: Lazy[ToUdtValue[H]],
    tToUdtValue: ToUdtValue[T]
  ): ToUdtValue[FieldType[K, H] :: T] = make { (in: FieldType[K, H] :: T, constructor: UdtValue) =>
    val headValue       = in.head
    val fieldName       = FieldName.Labelled(witness.value.name)
    val nextConstructor = hToUdtValue.value.convert(fieldName, headValue, constructor)

    tToUdtValue.convert(FieldName.Unused, in.tail, nextConstructor)
  }

  implicit val hNilToUdtValue: ToUdtValue[HNil] =
    make((_: HNil, constructor: UdtValue) => constructor)

  @nowarn("msg=is never used")
  implicit def genericToUdtValue[A, R](implicit
    gen: LabelledGeneric.Aux[A, R],
    ev: Lazy[ToUdtValue[R]],
    evidenceANotOption: A <:!< Option[_]
  ): ToUdtValue.Object[A] = { (fieldName: FieldName, in: A, constructor: UdtValue) =>
    fieldName match {
      case FieldName.Unused              => ev.value.convert(fieldName, gen.to(in), constructor)
      case FieldName.Labelled(fieldName) => nestedCaseClass(fieldName, gen.to(in), ev.value, constructor)
    }
  }

  def nestedCaseClass[A](fieldName: String, in: A, ev: ToUdtValue[A], top: UdtValue): UdtValue = {
    val constructor = top.getType(fieldName).asInstanceOf[UserDefinedType].newValue()
    val serialized  = ev.convert(FieldName.Unused, in, constructor)
    top.setUdtValue(fieldName, serialized)
  }
}
